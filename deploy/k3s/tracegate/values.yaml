namespace:
  name: tracegate

imagePullSecrets: []

controlPlane:
  enabled: true
  image:
    repository: ghcr.io/your-org/tracegate
    tag: "0.3.5"
    pullPolicy: IfNotPresent

  replicas:
    api: 1
    dispatcher: 1
    bot: 0

  dispatcherMetrics:
    enabled: true
    host: 0.0.0.0
    port: 9091

  service:
    type: ClusterIP
    port: 8080

  postgres:
    enabled: true
    image: postgres:16
    username: tracegate
    # Secret (provide via values override / .env-based deploy flow; never commit real value to git)
    password: ""
    database: tracegate
    storage: 10Gi
    storageClassName: ""

  externalDatabaseUrl: ""

  auth:
    # Secrets (provide via values override / .env-based deploy flow; never commit real values to git)
    apiInternalToken: ""
    agentAuthToken: ""
    botToken: ""

  # Telegram bot webhook mode avoids polling conflicts. It uses HTTPS on port 8443
  # (Telegram allows 8443) so it does not conflict with Xray/Hysteria on 443.
  botWebhook:
    enabled: false
    publicHost: ""     # e.g. t.example.com
    publicPort: 8443
    listenHost: 0.0.0.0
    listenPort: 8443
    # path/secretToken are generated and persisted as k8s secrets unless explicitly set.
    path: ""
    secretToken: ""
    uploadCert: true

  # /guide text can be overridden without touching DB by mounting it from a ConfigMap.
  # If disabled or text is empty, bot uses bundled default: bundles/bot/guide.md
  botGuide:
    enabled: false
    text: ""

  env:
    appEnv: prod
    logLevel: INFO
    publicBaseUrl: ""
    # JSON list, e.g. [123456789]. Used only to bootstrap role=superadmin on first user creation.
    superadminTelegramIds: []
    defaultVpsTHost: vps-t.example.com
    defaultVpsEHost: vps-e.example.com
    # Legacy REALITY material used as a fallback when per-role keys below are not set.
    realityPublicKey: ""
    realityShortId: ""
    # Optional per-role REALITY material. Required when B1 (direct to VPS-T) and B2 (chain via VPS-E)
    # terminate REALITY on different nodes with different keys/shortIds.
    realityPublicKeyVpsT: ""
    realityShortIdVpsT: ""
    realityPublicKeyVpsE: ""
    realityShortIdVpsE: ""
    wireguardServerPublicKey: ""
    vlessWsPath: /ws
    vlessWsTlsPort: 443
    grafana:
      enabled: false
      otpTtlSeconds: 300
      sessionTtlSeconds: 3600

  nodeSelector: {}
  tolerations: []
  affinity: {}
  terminationGracePeriodSeconds: 30
  pdb:
    enabled: true

  resources:
    api: {}
    dispatcher: {}
    bot: {}
    postgres: {}

gateway:
  enabled: true

  agentImage:
    repository: ghcr.io/your-org/tracegate
    tag: "0.3.5"
    pullPolicy: IfNotPresent

  splitter:
    transit:
      # Must match VPS-T static transit client id in Xray.
      uuid: "00000000-0000-4000-8000-000000000123"
      # If empty, falls back to controlPlane.env.realityPublicKey.
      publicKey: ""
      shortId: "0123456789abcdef"
      serverName: "splitter.wb.ru"
      upstreamHost: "vps-t.example.com"
      upstreamPort: 50000

  vpsT:
    enabled: true
    nodeSelector:
      tracegate.role: vps-t
    tolerations: []
    affinity: {}

    publicIPv4: 198.51.100.10
    fqdn: vps-t.example.com
    # Optional: a hostname expected to be proxied (e.g. Cloudflare orange cloud).
    # Use this for VLESS+WS+TLS if you want clients to connect via a proxied domain,
    # while keeping Reality/Hysteria on the direct fqdn/ip (DNS-only).
    proxyFqdn: ""

    hostNetwork: true
    shareProcessNamespace: true

    xray:
      image: ghcr.io/xtls/xray-core:latest
      pullPolicy: IfNotPresent
      config: |
        {
          "log": {"loglevel": "warning"},
          "api": {"tag":"api","listen":"127.0.0.1:8080","services":["HandlerService","StatsService"]},
          "stats": {},
          "policy": {
            "levels": {
              "0": {
                "statsUserUplink": true,
                "statsUserDownlink": true
              }
            },
            "system": {
              "statsInboundUplink": true,
              "statsInboundDownlink": true,
              "statsOutboundUplink": true,
              "statsOutboundDownlink": true
            }
          },
          "inbounds": [
            {
              "tag": "vless-reality-in",
              "listen": "0.0.0.0",
              "port": 443,
              "protocol": "vless",
              "settings": {
                "clients": [
                  {
                    "id": "{{ .Values.gateway.splitter.transit.uuid }}",
                    "email": "vps-e-transit"
                  }
                ],
                "decryption": "none"
              },
              "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                  "show": false,
                  "dest": "splitter.wb.ru:443",
                  "xver": 0,
                  "serverNames": ["splitter.wb.ru"],
                  "privateKey": "REPLACE_PRIVATE_KEY",
                  "shortIds": ["0123456789abcdef"]
                }
              }
            },
            {
              "tag": "vless-transit-in",
              "listen": "0.0.0.0",
              "port": 50000,
              "protocol": "vless",
              "settings": {
                "clients": [
                  {
                    "id": "{{ .Values.gateway.splitter.transit.uuid }}",
                    "email": "vps-e-transit"
                  }
                ],
                "decryption": "none"
              },
              "streamSettings": {
                "network": "tcp",
                "security": "none"
              }
            }
          ],
          "outbounds": [{"protocol": "freedom", "tag": "direct"}]
        }

    hysteria:
      image: tobyxdd/hysteria:v2
      pullPolicy: IfNotPresent
      config: |
        listen: :443
        acme:
          domains:
            - example.com
          email: admin@example.com
        auth:
          type: userpass
          userpass:
            bootstrap: bootstrap-password
        masquerade:
          type: file
          file:
            dir: /var/www/decoy
        trafficStats:
          listen: 127.0.0.1:9999
          secret: CHANGE_ME_HYSTERIA_STATS

    wireguard:
      image: ghcr.io/your-org/tracegate-wireguard:0.3.5
      pullPolicy: IfNotPresent
      interface: wg0
      config: |
        [Interface]
        Address = 10.70.0.1/24
        ListenPort = 51820
        PrivateKey = REPLACE_WG_PRIVATE_KEY
        SaveConfig = false

    decoyHtml: |
      <!doctype html>
      <html><head><meta charset="utf-8"><title>Tracegate</title></head><body><h1>It works.</h1></body></html>

    hysteriaTls:
      crt: ""
      key: ""

    agent:
      enabled: true
      host: 0.0.0.0
      port: 8070
      role: VPS_T
      authToken: ""
      dataRoot: /var/lib/tracegate-agent
      dryRun: false
      runtimeMode: kubernetes
      # Enable Xray gRPC API mode to add/remove users without restarting Xray.
      xrayApiEnabled: false
      xrayApiServer: 127.0.0.1:8080
      xrayApiTimeoutSeconds: 3
      statsUrl: http://127.0.0.1:9999/traffic
      statsSecret: ""
      wgInterface: wg0
      wgExpectedPort: 51820
      # Coalesce burst events into a single xray reload and avoid CrashLoopBackOff.
      reloadXrayCmd: sh -lc '(flock 9; sleep 1; pkill -HUP xray || true) 9>/tmp/xray-reload.lock'
      # Prefer graceful config reload to reduce client interruption.
      reloadHysteriaCmd: pkill -HUP hysteria || true
      # Apply wg-quick config by stripping it to wg format and syncing live interface.
      reloadWgCmd: wg-quick strip /etc/wireguard/wg0.conf | wg syncconf wg0 /dev/fd/0 || true

    agentDataHostPath: /var/lib/tracegate-agent

  vpsE:
    enabled: true
    nodeSelector:
      tracegate.role: vps-e
    tolerations: []
    affinity: {}

    publicIPv4: 198.51.100.20
    fqdn: vps-e.example.com
    proxyFqdn: ""

    hostNetwork: true
    shareProcessNamespace: true

    entryMux:
      image: nginx:1.24-alpine
      pullPolicy: IfNotPresent
      # Optional extra SNI hostnames that should be treated as VLESS+WS+TLS.
      # `proxyFqdn` is included automatically (if set).
      wsSniHosts: []

    # TLS certificate used to terminate VLESS+WS+TLS on VPS-E (chain mode / splitter).
    # Leave empty to generate and persist a self-signed cert in a k8s Secret.
    wsTls:
      crt: ""
      key: ""

    # "tcpForward" is the legacy v0.1 chain implementation: L4 forward :443 -> VPS-T:443.
    # "xray" enables VPS-E user mapping and split-routing (RU/domestic via VPS-E, rest via VPS-T transit).
    mode: tcpForward
    tcpForward:
      image: haproxy:2.9-alpine
      pullPolicy: IfNotPresent
      upstreamHost: vps-t.example.com
      upstreamPort: 443

    xray:
      image: ghcr.io/xtls/xray-core:latest
      pullPolicy: IfNotPresent
      # Splitter mode uses gateway.splitter.transit.* values for VPS-E -> VPS-T transit.
      config: |
        {
          "log": {"loglevel": "warning"},
          "api": {"tag":"api","listen":"127.0.0.1:8080","services":["HandlerService","StatsService"]},
          "stats": {},
          "policy": {
            "levels": {
              "0": {
                "statsUserUplink": true,
                "statsUserDownlink": true
              }
            },
            "system": {
              "statsInboundUplink": true,
              "statsInboundDownlink": true,
              "statsOutboundUplink": true,
              "statsOutboundDownlink": true
            }
          },
          "inbounds": [
            {
              "tag": "entry-in",
              "listen": "127.0.0.1",
              "port": 2443,
              "protocol": "vless",
              "settings": {"clients": [], "decryption": "none"},
              "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                  "show": false,
                  "dest": "splitter.wb.ru:443",
                  "xver": 0,
                  "serverNames": ["splitter.wb.ru"],
                  "privateKey": "REPLACE_PRIVATE_KEY",
                  "shortIds": ["fedcba9876543210"]
                }
              },
              "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls", "quic"]
              }
            },
            {
              "tag": "vless-ws-in",
              "listen": "127.0.0.1",
              "port": 10000,
              "protocol": "vless",
              "settings": {"clients": [], "decryption": "none"},
              "streamSettings": {
                "network": "ws",
                "security": "none",
                "wsSettings": {
                  "path": "{{ .Values.controlPlane.env.vlessWsPath | default "/ws" }}"
                }
              },
              "sniffing": {
                "enabled": true,
                "destOverride": ["http", "tls", "quic"]
              }
            }
          ],
          "outbounds": [
            {
              "tag": "direct",
              "protocol": "freedom"
            },
            {
              "tag": "to-transit",
              "protocol": "vless",
              "settings": {
                "vnext": [
                  {
                    "address": "{{ .Values.gateway.splitter.transit.upstreamHost }}",
                    "port": {{ .Values.gateway.splitter.transit.upstreamPort }},
                    "users": [
                      {
                        "id": "{{ .Values.gateway.splitter.transit.uuid }}",
                        "encryption": "none"
                      }
                    ]
                  }
                ]
              },
              "streamSettings": {
                "network": "tcp",
                "security": "none"
              }
            },
            {
              "tag": "block",
              "protocol": "blackhole"
            }
          ],
          "routing": {
            "domainStrategy": "IPIfNonMatch",
            "rules": [
              {
                "type": "field",
                "ip": ["geoip:private"],
                "outboundTag": "block"
              },
              {
                "type": "field",
                "inboundTag": ["entry-in", "vless-ws-in"],
                "domain": [
                  "geosite:category-ru",
                  "regexp:(?i)\\.ru$",
                  "regexp:(?i)\\.su$",
                  "regexp:(?i)\\.xn--p1ai$"
                ],
                "outboundTag": "direct"
              },
              {
                "type": "field",
                "inboundTag": ["entry-in", "vless-ws-in"],
                "ip": ["geoip:ru"],
                "outboundTag": "direct"
              },
              {
                "type": "field",
                "inboundTag": ["entry-in", "vless-ws-in"],
                "outboundTag": "to-transit"
              }
            ]
          }
        }

    agent:
      enabled: true
      host: 0.0.0.0
      port: 8070
      role: VPS_E
      authToken: ""
      dataRoot: /var/lib/tracegate-agent
      dryRun: false
      runtimeMode: kubernetes
      # Enable Xray gRPC API mode to add/remove users without restarting Xray.
      xrayApiEnabled: false
      xrayApiServer: 127.0.0.1:8080
      xrayApiTimeoutSeconds: 3
      statsUrl: http://127.0.0.1:9999/traffic
      statsSecret: ""
      wgInterface: wg0
      wgExpectedPort: 51820
      reloadXrayCmd: sh -lc '(flock 9; sleep 1; pkill -HUP xray || true) 9>/tmp/xray-reload.lock'
      reloadHysteriaCmd: ""
      reloadWgCmd: ""

    agentDataHostPath: /var/lib/tracegate-agent

registration:
  enabled: true
  hook: true
  retrySeconds: 60

observability:
  enabled: false

  prometheus:
    image: prom/prometheus:v2.52.0
    pullPolicy: IfNotPresent
    scrapeInterval: 15s
    storage:
      enabled: false
      size: 10Gi
      storageClassName: ""

  grafana:
    image: grafana/grafana:11.2.0
    pullPolicy: IfNotPresent
    # Secret; provide via values override.
    adminPassword: ""
    resources: {}

  nodeExporter:
    enabled: true
    image: prom/node-exporter:v1.8.1
    pullPolicy: IfNotPresent

  cadvisor:
    enabled: true
    image: gcr.io/cadvisor/cadvisor:v0.49.1
    pullPolicy: IfNotPresent
