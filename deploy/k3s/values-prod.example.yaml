controlPlane:
  image:
    repository: ghcr.io/your-org/tracegate
    tag: "0.3.5"
  auth:
    apiInternalToken: REPLACE_API_INTERNAL_TOKEN
    agentAuthToken: REPLACE_AGENT_AUTH_TOKEN
    botToken: ""
  botWebhook:
    enabled: true
    publicHost: t.example.com
    publicPort: 8443
  postgres:
    password: REPLACE_DB_PASSWORD
  env:
    publicBaseUrl: https://cp.example.com
    superadminTelegramIds: [123456789]
    defaultVpsTHost: vps-t.example.com
    defaultVpsEHost: vps-e.example.com
    # Legacy fallback REALITY material (used if per-role keys below are not set).
    realityPublicKey: REPLACE_REALITY_PUBLIC_KEY
    realityShortId: REPLACE_REALITY_SHORT_ID
    # Per-role REALITY material (recommended when VPS-T and VPS-E terminate REALITY with different keys).
    realityPublicKeyVpsT: ""
    realityShortIdVpsT: ""
    realityPublicKeyVpsE: ""
    realityShortIdVpsE: ""
    wireguardServerPublicKey: REPLACE_WG_SERVER_PUBLIC_KEY
    vlessWsPath: /ws
    vlessWsTlsPort: 443
    grafana:
      enabled: false

gateway:
  agentImage:
    repository: ghcr.io/your-org/tracegate
    tag: "0.3.5"

  splitter:
    transit:
      # Must match VPS-E outbound user id below.
      uuid: "00000000-0000-4000-8000-000000000123"
      # Transit REALITY public key of VPS-T (usually same as controlPlane.env.realityPublicKey).
      publicKey: REPLACE_REALITY_PUBLIC_KEY
      shortId: "0123456789abcdef"
      serverName: "google.com"
      upstreamHost: "vps-t.example.com"
      upstreamPort: 443

  vpsT:
    publicIPv4: 203.0.113.10
    fqdn: vps-t.example.com
    # Optional: proxied hostname for WS+TLS (e.g. ws-t.example.com with Cloudflare orange cloud).
    proxyFqdn: ""
    xray:
      config: |
        {
          "log": {"loglevel": "warning"},
          "api": {"tag":"api","listen":"127.0.0.1:8080","services":["HandlerService"]},
          "inbounds": [{"tag":"vless-reality-in","listen":"0.0.0.0","port":443,"protocol":"vless","settings":{"clients":[{"id":"{{ .Values.gateway.splitter.transit.uuid }}","email":"vps-e-transit"}],"decryption":"none"},"streamSettings":{"network":"tcp","security":"reality","realitySettings":{"show":false,"dest":"www.cloudflare.com:443","xver":0,"serverNames":["google.com","microsoft.com","yandex.ru","twitch.tv"],"privateKey":"REPLACE_PRIVATE_KEY","shortIds":["0123456789abcdef"]}}}],
          "outbounds": [{"protocol": "freedom", "tag": "direct"}]
        }
    hysteria:
      config: |
        listen: :443
        # For k3s mode, avoid ACME here: xray already occupies 443/tcp and ACME can hit rate limits.
        # Provide a cert via `gateway.vpsT.hysteriaTls` (recommended) or replace this config accordingly.
        tls:
          cert: /etc/hysteria/tls/tls.crt
          key: /etc/hysteria/tls/tls.key
        auth:
          type: userpass
          userpass:
            bootstrap: REPLACE_HYSTERIA_PASSWORD
        masquerade:
          type: file
          file:
            dir: /var/www/decoy
        trafficStats:
          listen: 127.0.0.1:9999
          secret: REPLACE_HYSTERIA_STATS_SECRET
    # Provide a TLS certificate for Hysteria2 (PEM). You can use a self-signed cert for v0.1,
    # but clients will need `insecure: true`.
    hysteriaTls:
      crt: ""
      key: ""
    wireguard:
      image: ghcr.io/your-org/tracegate-wireguard:0.3.5
      config: |
        [Interface]
        Address = 10.70.0.1/24
        ListenPort = 51820
        PrivateKey = REPLACE_WG_PRIVATE_KEY
        SaveConfig = false
    agent:
      authToken: REPLACE_AGENT_AUTH_TOKEN
      statsSecret: REPLACE_HYSTERIA_STATS_SECRET
      # Enable Xray gRPC API mode to add/remove users without restarting Xray.
      xrayApiEnabled: false
      xrayApiServer: 127.0.0.1:8080
      xrayApiTimeoutSeconds: 3
      reloadXrayCmd: sh -lc '(flock -n 9 || exit 0; sleep 1; pkill -HUP xray || true) 9>/tmp/xray-reload.lock'
      reloadHysteriaCmd: pkill -HUP hysteria || true
      reloadWgCmd: wg-quick strip /etc/wireguard/wg0.conf | wg syncconf wg0 /dev/fd/0 || true

  vpsE:
    publicIPv4: 203.0.113.20
    fqdn: vps-e.example.com
    # Recommended for CHAIN WS+TLS: set to a hostname that resolves to VPS-E (e.g. entry.example.com)
    # and provide a cert/key for it via `wsTls`.
    proxyFqdn: ""
    mode: xray
    entryMux:
      image: nginx:1.24-alpine
      pullPolicy: IfNotPresent
      wsSniHosts: []
    # TLS certificate used to terminate VLESS+WS+TLS on VPS-E (chain mode / splitter). PEM.
    wsTls:
      crt: ""
      key: ""
    tcpForward:
      upstreamHost: vps-t.example.com
      upstreamPort: 443
    # Splitter mode: transit parameters are taken from gateway.splitter.transit.*.
    xray:
      config: |
        {
          "log": {"loglevel": "warning"},
          "api": {"tag":"api","listen":"127.0.0.1:8080","services":["HandlerService"]},
          "inbounds": [
            {
              "tag":"entry-in",
              "listen":"127.0.0.1",
              "port":2443,
              "protocol":"vless",
              "settings":{"clients":[],"decryption":"none"},
              "streamSettings":{"network":"tcp","security":"reality","realitySettings":{"show":false,"dest":"vps-t.example.com:443","xver":0,"serverNames":["google.com","microsoft.com","yandex.ru","twitch.tv"],"privateKey":"REPLACE_PRIVATE_KEY","shortIds":["fedcba9876543210"]}},
              "sniffing":{"enabled":true,"destOverride":["http","tls","quic"]}
            },
            {
              "tag":"vless-ws-in",
              "listen":"127.0.0.1",
              "port":10000,
              "protocol":"vless",
              "settings":{"clients":[],"decryption":"none"},
              "streamSettings":{"network":"ws","security":"none","wsSettings":{"path":"{{ .Values.controlPlane.env.vlessWsPath | default "/ws" }}"}},
              "sniffing":{"enabled":true,"destOverride":["http","tls","quic"]}
            }
          ],
          "outbounds": [
            {"tag":"direct","protocol":"freedom"},
            {"tag":"to-transit","protocol":"vless","settings":{"vnext":[{"address":"{{ .Values.gateway.splitter.transit.upstreamHost }}","port":{{ .Values.gateway.splitter.transit.upstreamPort }},"users":[{"id":"{{ .Values.gateway.splitter.transit.uuid }}","encryption":"none"}]}]},"streamSettings":{"network":"tcp","security":"reality","realitySettings":{"serverName":"{{ .Values.gateway.splitter.transit.serverName }}","publicKey":"{{ .Values.gateway.splitter.transit.publicKey }}","shortId":"{{ .Values.gateway.splitter.transit.shortId }}"}}},
            {"tag":"block","protocol":"blackhole"}
          ],
          "routing": {
            "domainStrategy":"IPIfNonMatch",
            "rules":[
              {"type":"field","ip":["geoip:private"],"outboundTag":"block"},
              {"type":"field","inboundTag":["entry-in","vless-ws-in"],"domain":["geosite:category-ru","regexp:(?i)\\.ru$","regexp:(?i)\\.su$","regexp:(?i)\\.xn--p1ai$"],"outboundTag":"direct"},
              {"type":"field","inboundTag":["entry-in","vless-ws-in"],"ip":["geoip:ru"],"outboundTag":"direct"},
              {"type":"field","inboundTag":["entry-in","vless-ws-in"],"outboundTag":"to-transit"}
            ]
          }
        }
    agent:
      authToken: REPLACE_AGENT_AUTH_TOKEN
      # Enable Xray gRPC API mode to add/remove users without restarting Xray.
      xrayApiEnabled: false
      xrayApiServer: 127.0.0.1:8080
      xrayApiTimeoutSeconds: 3

observability:
  enabled: false
  grafana:
    # Optional; if empty, the chart will generate and persist a random password in a Secret.
    adminPassword: ""
